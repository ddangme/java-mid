# 목차
1. [제네릭이 필요한 이유](#제네릭이-필요한-이유)
2. [다형성을 통한 중복 해결 시도](#다형성을-통한-중복-해결-시도)
3. [제네릭 적용](#제네릭-적용)
4. [제네릭 용어와 관례](#제네릭-용어와-관례)
5. [제네릭 활용 예제](#제네릭-활용-예제)
6. [타입 매개변수 제한1 - 시작](#타입-매개변수-제한1---시작)
7. [타입 매개변수 제한2 - 다형성 시도](#타입-매개변수-제한2---다형성-시도-)
8. [타입 매개변수 제한3 - 제네릭 도입과 실패](#타입-매개변수-제한3---제네릭-도입과-실패-)
9. [타입 매개변수 제한4 - 타입 매개변수 제한](#타입-매개변수-제한4---타입-매개변수-제한)
10. [제네릭 메서드](#제네릭-메서드)
11. [제네릭 메서드 활용](#제네릭-메서드-활용)
12. [와일드 카드](#와일드카드)
13. [타입 이레이저](#타입-이레이저)
14. [정리](#정리)

## 제네릭이 필요한 이유
대부분 최신 프로그래밍 언어는 제네릭(`Generic`) 개념을 제공한다.

### [IntegerBox.java](..%2Fsrc%2Fgeneric%2Fex1%2FIntegerBox.java)
```java
public class IntegerBox {

    private Integer value;

    public void set(Integer value) {
        this.value = value;
    }

    public Integer get() {
        return value;
    }
}
```
- 숫자를 보관하고 꺼낼 수 있는 단순한 기능을 제공한다.

### [StringBox.java](..%2Fsrc%2Fgeneric%2Fex1%2FStringBox.java)
```java
public class StringBox {

    private String value;

    public void set(String value) {
        this.value = value;
    }

    public String get() {
        return value;
    }
}
```
- 문자열을 보관하고 꺼낼 수 있는 단순한 기능을 제공한다.

### [BoxMain1.java](..%2Fsrc%2Fgeneric%2Fex1%2FBoxMain1.java)
```java
public class BoxMain1 {

    public static void main(String[] args) {
        IntegerBox integerBox = new IntegerBox();
        integerBox.set(10);  // 오토 박싱
        Integer integer = integerBox.get();
        System.out.println("integer = " + integer);

        StringBox stringBox = new StringBox();
        stringBox.set("hello");
        String str = stringBox.get();
        System.out.println("str = " + str);
    }
}
```

#### 실행 결과
```text
integer = 10
str = hello
```

### 코드 분석
코드를 보면 먼저 숫자를 보관하는 `IntegerBox`를 생성하고, 그곳에 숫자 `10`을 보관하고, 꺼낸 다음에 출력한다.
(참고로 오토 박싱에 의해 `int`가 `Integer`로 자동 변환된다.)  
다음으로 문자열을 보관하는 `StringBox`를 생성하고 그곳에 문자열 `"hello"`를 보관하고, 꺼낸 다음에 출력한다.

### 문제
이후에 `Double`, `Boolean`을 포함한 다양한 타입을 담는 박스가 필요하다면 각각의 타입별로 `DoubleBox`, `BooleanBox`와 같이
새로운 클래스를 만들어야 한다.
담는 타입이 수십개 라면, 수십개의 `XxxBox` 클래스를 만들어야 한다.

## 다형성을 통한 중복 해결 시도
`Object`는 모든 타입의 부모이다.
따라서 다형성(다형적 참조)를 사용해서 이 문제를 간단히 해결할 수 있을 것 같다.

### [ObjectBox.java](..%2Fsrc%2Fgeneric%2Fex1%2FObjectBox.java)
```java
public class ObjectBox {
    private Object value;

    public void set(Object value) {
        this.value = value;
    }

    public Object get() {
        return value;
    }
}
```
- 내부에 `Object value`를 가지고 있다.
- `Object`는 모든 타입의 부모이다.
- 부모는 자식을 담을 수 있으므로 세상의 모든 타입을 `ObejctBox`에 보관할 수 있다.

### [BoxMain2.java](..%2Fsrc%2Fgeneric%2Fex1%2FBoxMain2.java)
```java
public class BoxMain2 {

    public static void main(String[] args) {
        ObjectBox integerBox = new ObjectBox();
        integerBox.set(10);

        Integer integer = (Integer) integerBox.get(); // Object -> Integer 다운 캐스팅
        System.out.println("integer = " + integer);

        ObjectBox stringBox = new ObjectBox();
        stringBox.set("hello");

        String str = (String) stringBox.get(); // Object -> String 다운 캐스팅
        System.out.println("str = " + str);

        // 잘못된 타입의 인수 전달
        integerBox.set("문자 100");
        Integer result = (Integer) integerBox.get();

        System.out.println("result = " + result);
    }
}
```

#### 실행 결과
```text
integer = 10
str = hello
Exception in thread "main" java.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Integer (java.lang.String and java.lang.Integer are in module java.base of loader 'bootstrap')
	at generic.ex1.BoxMain2.main(BoxMain2.java:20)
```
잘 동작하는 것 같지만 몇 가지 문제가 있다.

### 반환 타입이 맞지 않는 문제
먼저 `integerBox`를 만들어서 숫자 `10`을 보관했다. 숫자를 입력하는 부분에는 문제가 없어 보이지만,
`integerBox.get()`을 호출할 때 문제가 나타난다.

`integerGox.get()` 반환 타입은 `Object`이다.
```java
Object obj = integerBox.get();
```
`Integer = Object`는 성립하지 않는다. 자식은 부모를 담을 수 없다.
따라서 다음과 같이 `(Integer)` 타입 캐스팅 코드를 넣어서 `Object` 타입을 `Integer` 타입으로
직접 다운 캐스팅해야 한다.
```java
Integer integer = (Integer) integerBox.get();
Integer integer = (Integer) (Object)value;
Integer integer = (Integer)value;
```

`stringBox`의 경우도 마찬가지이다. `stringBox.get()`이 `Object`를 반환하므로 다음과 같이 다운 캐스팅해야 한다.
```java
String str = (String) stringBox.get();
```

### 잘못된 타입의 인수 전달 문제
```java
integerBox.set("문자 100");
```
개발자의 의도는 `integerBox`에는 변수 이름과 같이 숫자 타입이 입력되기를 기대했다.   
하지만 `set(Object ..)` 메서드는 모든 타입의 부모인 `Object`를 매개변수로 받기 때문에 세상의 어떤 데이터도
입력받을 수 있다. 따라서 이렇게 문자열을 입력해도 자바 언어 입장에서는 아무 문제가 되지 않는다.

잘못된 타입의 값을 전달하면 값을 꺼낼 때 문제가 발생한다.
```java

Integer result = (Integer) integerBox.get();
Integer result = (Integer) "문자100";
Integer result = (Integer) "문자100"; // 예외 발생 String을 Integer로 캐스팅할 수 없다.
```
숫자가 들어가 있을 것으로 예상한 박스에는 문자열이 들어가 있었다. 결과적으로 다운 캐스팅 시 `String`을
`Integer`로 캐스팅 할 수 없다는 예외가 발생하고 프로그램이 종료된다.

### 정리
다형성을 활용한 덕분에 코드의 중복을 제거하고, 기존 코드를 재사용할 수 있게 되었다.
하지만 입력할 때 실수로 원하지 않는 타입이 들어갈 수 있는 타입 안전성 문제가 발생한다.
예를 들어서 `integerBox`에는 숫자만 넣어야 하고, `stringBox`에는 문자열만 입력할 수 있어야 한다.
하지만 박스에 값을 보관하는 `set()`의 매개변수가 `Object`이기 때문에 다른 타입의 값을 입력할 수 있다.
그리고 반환 시점에도 `Object`를 반환하기 때문에 원하는 타입을 정확하게 받을 수 없고, 항상 위험한
다운 캐스팅을 시도해야 한다.
결과적으로 이 방식은 타입 안전성이 떨어진다.

지금까지 개발한 프로그램은 코드 재사용과 타입 안전성이라는 2마리 토끼를 한 번에 잡을 수 없다.
코드 재사용을 늘리기 위해 `Object`와 다형성을 사용하면 타입 안전성이 떨어지는 문제가 발생한다.
- `BoxMain1`: 각각의 타입별로 `IntegerBox`, `StringBox`와 같은 클래스를 모두 정의
  - 코드 재사용 불가
  - 타입 안전성 있음
- `BoxMain2`: `ObjectBox`를 사용해서 다형성으로 하나의 클래스만 정의
  - 코드 재사용 가능
  - 타입 안전성 떨어짐

## 제네릭 적용
제네릭을 사용하면 코드 재사용과 타입 안전성이라는 두 마리 토끼를 한 번에 잡을 수 있다.  
제네릭을 사용해서 문제를 해결해보자.

### [GenericBox.java](..%2Fsrc%2Fgeneric%2Fex1%2FGenericBox.java)
```java
public class GenericBox<T> {
    
    private T value;

    public void set(T value) {
        this.value = value;
    }

    public T get() {
        return value;
    }
}
```
- `<>`를 사용한 클래스를 제네릭 클래스라고 한다.
- 이 기호 `<>`는 보통 다이아몬드라고 한다.
- 제네릭 클래스를 사용 할 때는 `Integer`, `String` 같은 타입을 미리 결정하지 않는다.
- 대신에 클래스명 오른쪽에 `<T>`와 같이 선언하면 제네릭 클래스가 된다.
- 여기서 `T` 타입을 **타입 매개변수**라고 한다.
- 이 타입 매개변수는 이후에 `Integer`, `String`으로 변할 수 있다.
- 그리고 클래스 내부에 `T` 타입이 필요한 곳에 `T value`와 같이 타입 매개변수를 적어두면 된다.

### [BoxMain3.java](..%2Fsrc%2Fgeneric%2Fex1%2FBoxMain3.java) 
```java
public class BoxMain3 {

    public static void main(String[] args) {
        GenericBox<Integer> integerBox = new GenericBox<Integer>(); // 생성 시점에 T의 타입 결정
        integerBox.set(10);

        // integerBox.set("문자100"); // Integer 타입만 허용, 컴파일 오류
        Integer integer = integerBox.get(); // Integer 타입 반환 (캐스팅 X)
        System.out.println("integer = " + integer);

        GenericBox<String> stringBox = new GenericBox<String>();
        stringBox.set("hello"); // String 타입만 허용
        String str = stringBox.get(); // String 타입 반환
        System.out.println("str = " + str);

        // 원하는 모든 타입 사용 가능
        GenericBox<Double> doubleBox = new GenericBox<Double>();
        doubleBox.set(10.5);
        Double doubleValue = doubleBox.get();
        System.out.println("doubleValue = " + doubleValue);

        // 타입 추론: 생성하는 제네릭 타입 생략 가능
        GenericBox<Integer> integerBox2 = new GenericBox<>();
    }
}
```

#### 실행 결과
```text
integer = 10
str = hello
doubleValue = 10.5
```

### 생성 시점에 원하는 타입 지정
제네릭 클래스는 다음과 정의한다. `<>` (다이아몬드 기호)안에 타입 매개변수를 정의하면 된다.
```java
class GenericBox<T>
```

제네릭 클래스는 생성하는 시점에 `<>` 사이에 원하는 타입을 지정한다.
```java
new GenericBox<Integer>()
```
이렇게 하면 앞서 정의한 `GenericBox`의 `T`가 다음과 같이 지정한 타입으로 변한 다음 생성된다.

- T에 Integer를 적용한 GenericBox 클래스
```java
public class GenericBox<Integer> {
    private Integer value;

  public void set(Integer value) {
      this.value = value;
  }
  
  public Integer get() {
      return value;
  }
}
```
`T`가 모두 `Integer`로 변한다. 따라서 `Integer` 타입을 입력하고 조회할 수 있다.

이제 `set(Integer value)` 이므로 이 메서드에는 `Integer` 숫자만 담을 수 있다.
```java
integerBox.set(10); // 성공
integerBox.set("문자 100") // Integer 타입만 허용, 컴파일 오류
```

`get()`의 경우에도 `Integer`를 반환하기 때문에 타입 캐스팅 없이 숫자 타입으로 조회할 수 있다.
```java
Integer integer = integerBox.get(); // Integer 타입 반환 (캐스팅 X)
```

`String`을 사용하면 다음과 같다.
`new GenericBox<String>()`

- T에 String을 적용한 Generic 클래스
```java
public class GenericBox<String> {
    private String value;

  public void set(String value) {
      this.value = value;
  }
  
  public String get() {
      return value;
  }
}
```
`T` 가 모두 `String` 으로 변한다. 따라서 문자열을 입력하고, 문자열을 그대로 조회할 수 있다.

### 원하는 모든 타입 사용 가능
제네릭 클래스를 사용하면 다음과 같이 `GenericBox` 객체를 생성하는 시점에 원하는 타입을 마음껏 지정할 수 있다.
```java
new GenericBox<Double>()
new GenericBox<Boolean>()
new GenericBox<MyClass>()
```

참고로 제네릭을 도입한다고 해서 앞서 설명한 `GenericBox<String>`, `GenericBox<Integer>`와 같은 코드가
실제 만들어지는 것은 아니다. 대신에 자바 컴파일러가 우리가 입력한 타입 정보를 기반으로 이런 코드가 있다고 가정하고
컴파일 과정에 타입 정보를 반영한다. 이 과정에서 타입이 맞지 않으면 컴파일 오류가 발생한다.

### 타입 추론
```java
GenericBox<Integer> integerBox = new GenericBox<Integer>() // 타입 직접 입력 
GenericBox<Integer> integerBox2 = new GenericBox<>() // 타입 추론
```
첫번째 줄의 코드를 보면 변수를 선언할 때와 객체를 생성할 때 `<Integer>`가 두 번 나온다.
자바는 왼쪽에 있는 변수를 선언할 때의 `<Integer>`를 보고 오른쪽에 있는 객체를 생성할 때 필요한 타입 정보를 얻을 수 있다.
따라서 두 번째 줄의 오른쪽 코드 `new GenericBox<>()`와 같이 타입 정보를 생략할 수 있다.
이렇게 자바가 스스로 타입 정보를 추론해서 개발자가 타입 정보를 생략할 수 있는 것을 **타입 추론**이라고 한다.

참고로 타입 추론이 그냥 되는 것은 아니고, 자바 컴파일러가 타입을 추론할 수 있는 상황에만 가능하다.
쉽게 이야기해서 읽을 수 있는 타입정보가 주변에 있어야 추론할 수 있다.

### 정리
제네릭을 사용한 덕분에 코드 재사용과 타입 안전성이라는 두 마리 토끼를 모두 잡을 수 있었다.

## 제네릭 용어와 관례
제네릭의 핵심은 **사용할 타입을 미리 결정하지 않는 다는 점**이다. 
클래스 내부에서 사용하는 타입을 클래스를 정의하는 시점에 결정하는 것이 아니라, 
실제 사용하는 생성 시점에 타입을 결정하는 것이다.   
이것을 쉽게 비유하자면 메서드의 매개변수와 인자의 관계와 비슷하다.

### 메서드에 필요한 값을 메서드 정의 시점에 미리 결정
```java
void method1() {
    println("hello");
}
```
- 메서드에 필요한 값을 이렇게 메서드 정의 시점에 미리 결정하게 되면, 이 메서드는 오직 `"hello"`라는 값만
출력할 수 있다. 따라서 재사용성이 떨어진다.

### 메서드에 필요한 값을 인자를 통해 매개변수로 전달해서 결정
```java
void method2(String param) {
    println(param);
}

void main() {
    method2("hello");
    method2("hi");
}
```
- 메서드에 필요한 값을 메서드를 정의하는 시점에 미리 결정하는 것이 아니라, 메서드를 실제 사용하는 시점으로 미룰 수 있다.
- 메서드에 매개변수(`String param`)을 지정하고, 메서드를 사용할 때 원하는 값을 인자(`"hello"`, `"hi"`)로 전달하면 된다.

### 다양한 값을 처리하는 메서드
```java
// method2("hello") 호출 예
void method2(String param="hello") {
  println(param);
}

//method2("hi") 호출 예
void method2(String param="hi") {
  println(param);
}
```
- 매개변수를 정의하고, 실행 시점에 인자를 통해 원하는 값을 매개변수에 전달했다.
- 이렇게하면 이 메서드는 실행 시점에 얼마든지 다른 값을 받아서 처리할 수 있다.
- 따라서 재사용성이 크게 늘어난다.

### 메서드의 매개변수와 인자
```java
void method(String param) // 매개 변수

void main() {
    String arg = "hello";
    method(arg); // 인수 전달
}
```
- 매개변수 (Parameter): `String param`
- 인자, 인수(Argument): `arg`

메서드의 매개변수에 인자를 전달해서 메서드의 사용 값을 결정한다.

### 제네릭의 타입 매개변수와 타입 인자
제네릭도 앞서 설명한 메서드의 매개변수와 인자의 관계와 비슷하게 작동한다.

제네릭 클래스를 정의할 때 내부에서 사용할 타입을 미리 결정하는 것이 아니라, 해당 클래스를 실제 사용하는 생성 시점에
내부에서 사용할 타입을 결정하는 것이다.
차이가 있다면 **메서드의 매개변수는 사용할 값에 대한 결정을 나중으로 미루는 것**이고,
**제네릭의 타입 매개변수는 사용할 타입에 대한 결정을 나중으로 미루는 것**이다.

정리하면 다음과 같다.
- 메서드는 **매개변수**에 **인자**를 전달해서 사용할 값을 결정한다.
- 제네릭 클래스는 **타입 매개변수**애 **타입 인자**를 전달해서 사용할 타입을 결정한다.

제네릭에서 사용하는 용어도 매개변수, 인자의 용어를 그대로 가져다가 사용한다. 다만 값이 아니라 **타입을 결정**하는 것이기 
때문에 앞에 타입을 붙인다.
- 타입 매개변수: `GenericBox<T>`에서 `T`
- 타입 인자
  - `GenericBox<Integer>`에서 `Integer`
  - `GenericBox<String>`에서 `String`

제네릭 타입의 타입 매개변수 `<T>`에 타입 인자를 전달해서 제네릭의 사용 타입을 결정한다.
- `GenericBox<T>`
  - `String` ➡️ `GenericBox<String>`
  - `Integer` ➡️ `GenericBox<Integer>`

### 용어 정리
- 제네릭(Generic)
  - 일반적인, 범용적인이라는 뜻을 가지고 있다.
  - 풀어보면 특정 타입에 속한 것이 아니라 일반적으로, 범용적으로 사용할 수 있다는 뜻이다.
- 제네릭 타입 (Generic Type)
  - 클래스나 인터페이스를 정의할 때 타입 매개변수를 사용하는 것을 말한다.
  - 제네릭 클래스, 제네릭 인터페이스를 모두 합쳐서 제네릭 타입이라고 한다.
    - 타입은 클래스, 인터페이스, 기본형 (`int` 등)을 모두 합쳐서 부르는 말이다.
  - 예) `class GenericBox<T> { private T t; }`
  - 여기에서 `GenericBox<T>`를 제네릭 타입이라고 한다.
- 타입 매개변수 (Type Parameter)
  - 제네릭 타입이나 메서드에서 사용하는 변수로, 실제 타입으로 대체된다.
  - 예) `GenericBox<T>`
  - 여기에서 `T`를 타입 매개변수라고 한다.
- 타입 인자 (Type Argument)
  - 제네릭 타입을 사용할 때 제공되는 실제 타입이다.
  - 예) `GenericBox<Integer>`
  - 여기에서 `Integer`를 타입 인자라고 한다.

### 제네릭 명명 관례
타입 매개변수는 일반적인 변수명처럼 소문자로 사용해도 문제는 없다.  
하지만 일반적으로 대문자를 사용하고 용도에 맞는 단어의 첫글자를 사용하는 관례를 따른다.

주로 사용하는 키워드는 다음과 같다.

| 키워드        | 설명                  |
|------------|---------------------|
| E          | Element             |
| K          | Key                 |
| N          | Number              |
| T          | Type                |
| V          | Value               |
| S,U,V etc. | 2nd, 3rd, 4th types |

### 제네릭 기타
다음과 같이 한 번에 여러 타입 매개변수를 선언할 수 있다.
```java
class Data<K, V> { }
```

**타입 인자로 기본형은 사용할 수 없다.**  
제네릭의 타입 인자로 기본형 (`int`, `double` .. )은 사용할 수 없다.
대산에 래퍼 클래스(`Integer`, `Double`)를 사용하면 된다.

### Raw Type
#### [RawTypeMain.java](..%2Fsrc%2Fgeneric%2Fex1%2FRawTypeMain.java)
```java
public class RawTypeMain {

    public static void main(String[] args) {
        GenericBox integerBox = new GenericBox();

        // GenericBox<Object> integerBox = new GenericBox<>(); 권장
        integerBox.set(10);
        Integer result = (Integer) integerBox.get();
        System.out.println("result = " + result);
    }
}
```

##### 실행 결과
```text
result = 10
```

제네릭 타입을 사용할 때는 항상 `<>`를 사용해서 사용시점에 원하는 타입을 지정해야 한다.  
그런데 다음과 같이 `<>`를 지정하지 않을 수 있는데, 이런 것을 로 타입 (`raw type`), 또는 원시 타입이라고 한다.
원시 타입을 사용하면 내부의 타입 매개변수가 `Object`로 사용된다고 이해하면 된다.

제네릭 타입을 사용할 때는 항상 `<>`를 사용해서 사용시점에 타입을 지정해야 한다. 그런데 왜 이런 로 타입을 지원하는 것일까?

자바의 제네릭이 자바가 처음 등장할 때 부터 있었던 것이 아니라 자바가 오랜기간 사용된 이후에 등장했기 때문에
제네릭이 없던 시절의 과거 코드와의 하위 호환이 필요했다. 그래서 어쩔 수 없이 이런 로 타입을 지원한다.

## 제네릭 활용 예제
이번에는 직접 클래스를 만들고, 제네릭을 도입해보자.

### [Animal.java](..%2Fsrc%2Fgeneric%2Fanimal%2FAnimal.java) 
```java
public class Animal {

    private String name;
    private int size;

    public Animal(String name, int size) {
        this.name = name;
        this.size = size;
    }

    public String getName() {
        return name;
    }

    public int getSize() {
        return size;
    }
    
    public void sound() {
        System.out.println("동물 울음 소리");
    }

    @Override
    public String toString() {
        return "Animal{" +
                "name='" + name + '\'' +
                ", size=" + size +
                '}';
    }
}
```
- 이름과 크기 정보를 가지는 부모 클래스이다.

### [Dog.java](..%2Fsrc%2Fgeneric%2Fanimal%2FDog.java)
```java
public class Dog extends Animal {

    public Dog(String name, int size) {
        super(name, size);
    }

    @Override
    public void sound() {
        System.out.println("멍멍");
    }
}
```
- `Animal`을 상속받는다.
- 부모 클래스에 정의된 생성자가 있기 때문에 맞추어 `super(name, size)`를 호출한다.

### [Cat.java](..%2Fsrc%2Fgeneric%2Fanimal%2FCat.java)
```java
public class Cat extends Animal {

    public Cat(String name, int size) {
        super(name, size);
    }

    @Override
    public void sound() {
        System.out.println("야옹");
    }
}
```

### [Box.java](..%2Fsrc%2Fgeneric%2Fex2%2FBox.java)
```java
public class Box<T> {
    
    private T value;

    public void setValue(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}
```
- 객체를 보관할 수 있는 제네릭 클래스이다.

### [AnimalMain1.java](..%2Fsrc%2Fgeneric%2Fex2%2FAnimalMain1.java)
```java
public class AnimalMain1 {

    public static void main(String[] args) {
        Animal animal = new Animal("동물", 0);
        Dog dog = new Dog("멍멍이", 100);
        Cat cat = new Cat("냐옹이", 50);

        Box<Dog> dogBox = new Box<>();
        dogBox.setValue(dog);
        Dog findDog = dogBox.getValue();
        System.out.println("findDog = " + findDog);

        Box<Cat> catBox = new Box<>();
        catBox.setValue(cat);
        Cat findCat = catBox.getValue();
        System.out.println("findCat = " + findCat);

        Box<Animal> animalBox = new Box<>();
        animalBox.setValue(animal);
        Animal findAnimal = animalBox.getValue();
        System.out.println("findAnimal = " + findAnimal);
    }
}
```

#### 실행 결과
```text
findDog = Animal{name='멍멍이', size=100}
findCat = Animal{name='냐옹이', size=50}
findAnimal = Animal{name='동물', size=0}
```

- `Box` 제네릭 클래스에 각각의 타입에 맞는 동물을 보관하고 꺼낸다.
- `Box<Dog> dogBox`
  - `Dog` 타입을 보관할 수 있다.
- `Box<Cat> catBox`
  - `Cat` 타입을 보관할 수 있다.
- `Box<Animal> animalBox`
  - `Animal` 타입을 보관할 수 있다.


여기서 `Box<Animal>`의 경우 타입 매개변수 `T`에 타입 인자 `Animal`을 대입하면 다음 코드와 같다.
```java
public class Box<Animal> {
    private Animal value;
    
    public void set(Animal value) {
        this.value = value;
    }
    
    public Animal get() {
        return value;
    } 
}
```
- 따라서 `set(Animal value)` 이므로 `set()`에 `Animal`의 하위 타입인 `Dog`, `Cat` 도 전달할 수 있다.
- 물론 이 경우 꺼낼 때는 `Animal` 타입으로만 꺼낼 수 있다.

### [AnimalMain2.java](..%2Fsrc%2Fgeneric%2Fex2%2FAnimalMain2.java)
```java
public class AnimalMain2 {

    public static void main(String[] args) {
        Animal animal = new Animal("동물", 0);
        Dog dog = new Dog("멍멍이", 100);
        Cat cat = new Cat("냐옹이", 50);

        Box<Animal> animalBox = new Box<>();
        animalBox.setValue(animal);
        animalBox.setValue(dog);
        animalBox.setValue(cat);
        Animal findAnimal = animalBox.getValue();
        System.out.println("findAnimal = " + findAnimal);
    }
}
```

#### 실행 결과
```text
findAnimal = Animal{name='냐옹이', size=50}
```

## 타입 매개변수 제한1 - 시작
요구사항: 개 병원은 개만 받을 수 있고, 고양이 병원은 고양이만 받을 수 있어야 한다.
### [DobHospital](..%2Fsrc%2Fgeneric%2Fex3%2FDogHospital.java)
```java
public class DogHospital {
    private Dog animal;

    public void set(Dog animal) {
        this.animal = animal;
    }

    public void checkup() {
        System.out.println("동물 이름: " + animal.getName());
        System.out.println("동물 크기: " + animal.getSize());
        animal.sound();
    }

    public Dog bigger(Dog target) {
        return animal.getSize() > target.getSize() ? animal : target;
    }
}
```
- 개 병원은 내부에 `Dog` 타입을 갖는다.
- `checkup()`: 개의 이름과 크기를 출력하고, 개의 `sound()` 메서드를 호출한다.
- `bigger()`: 다른 개와 크기를 비교한다. 둘 중에 큰 개를 반환한다.

### [CatHospital](..%2Fsrc%2Fgeneric%2Fex3%2FCatHospital.java)
```java
public class CatHospital {
    private Cat animal;
    
    public void set(Cat animal) {
        this.animal = animal;
    }
    
    public void checkup() {
        System.out.println("동물 이름: " + animal.getName());
        System.out.println("동물 크기: " + animal.getSize()); 
        animal.sound();
    }
    
    public Cat getBigger(Cat target) {
        return animal.getSize() > target.getSize() ? animal : target;
    }
}
```
- 고양이 병원은 내부에 `Cat` 타입을 가진다.
- `checkup()` : 고양이의 이름과 크기를 출력하고, 고양이의 `sound()` 메서드를 호출한다.
- `bigger()` : 다른 고양이와 크기를 비교한다. 둘 중에 큰 고양이를 반환한다.

### [AnimalHospitalMainV0](..%2Fsrc%2Fgeneric%2Fex3%2FAnimalHospitalMainV0.java)
```java
public class AnimalHospitalMainV0 {

    public static void main(String[] args) {
        DogHospital dogHospital = new DogHospital();
        CatHospital catHospital = new CatHospital();
        Dog dog = new Dog("멍멍이1", 100);
        Cat cat = new Cat("냐옹이1", 300);

        // 개 병원
        dogHospital.set(dog); dogHospital.checkup();
        // 고양이 병원
        catHospital.set(cat); catHospital.checkup();

        // 문제1: 개 병원에 고양이 전달
        // dogHospital.set(cat); // 다른 타입 입력: 컴파일 오류

        // 문제2: 개 타입 반환
        dogHospital.set(dog);
        Dog biggerDog = dogHospital.bigger(new Dog("멍멍이2", 200));
        System.out.println("biggerDog = " + biggerDog);
    }
}
```

#### 실행 결과
```text
동물 이름: 멍멍이1
동물 크기: 100
멍멍
동물 이름: 냐옹이1
동물 크기: 300
야옹
biggerDog = Animal{name='멍멍이2', size=200}
```
이번에 만든 코드는 처음에 제시한 다음 요구사항을 명확히 잘 지킨다.  
여기서는 개 병원과 고양이 병원을 각각 별도의 클래스로 만들었다.  
각 클래스별로 타입이 명확하기 때문에 개 병원은 개만 받을 수 있고, 고양이 병원은 고양이만 받을 수 있다. 따라서 개 병원에 고양이를 전달하면 컴파일 오류가 발생한다.  
그리고 개 병원에서 `bigger()`로 다른 개를 비교하는 경우 더 큰 개를 `Dog` 타입으로 반환한다.

### 문제
1. 코드 재사용 X
   - 개 병원과 고양이 병원은 중복이 많다.
2. 타입 안정성 O
   - 타입 안전성이 명확하게 지켜진다.

## 타입 매개변수 제한2 - 다형성 시도
`Dog`, `Cat`은 `Animal`이라는 명확한 부모 타입이 있다. 타형성을 사용해서 중복을 제거하자

### [AnimalHospitalV1](..%2Fsrc%2Fgeneric%2Fex3%2FAnimalHospitalV1.java)
```java
public class AnimalHospitalV1 {

    private Animal animal;

    public void set(Animal animal) {
        this.animal = animal;
    }

    public void check() {
        System.out.println("동물 이름: " + animal.getName());
        System.out.println("동물 크기: " + animal.getSize());
        animal.sound();
    }

    public Animal getBigger(Animal target) {
        return animal.getSize() > target.getSize() ? animal : target;
    }
}
```
- Animal` 타입을 받아서 처리한다.
- `checkup()` , `getBigger()` 에서 사용하는 `animal.getName()` , `animal.getSize()` , `animal.sound()` 메서드는 모두 `Animal` 타입이 제공하는 메서드이다. 따라서 아무 문제없이 모두 호출할
  수 있다.

### [AnimalHospitalMainV1](..%2Fsrc%2Fgeneric%2Fex3%2FAnimalHospitalMainV1.java)
```java
public class AnimalHospitalMainV1 {

    public static void main(String[] args) {
        AnimalHospitalV1 dogHospital = new AnimalHospitalV1();
        AnimalHospitalV1 catHospital = new AnimalHospitalV1();
        Dog dog = new Dog("멍멍이1", 100);
        Cat cat = new Cat("냐옹이1", 300);

        // 개 병원
        dogHospital.set(dog); dogHospital.checkup();

        // 고양이 병원
        catHospital.set(cat);
        catHospital.checkup();

        // 문제1: 개 병원에 고양이 전달
        dogHospital.set(cat); // 매개변수 체크 실패: 컴파일 오류가 발생하지 않음

        // 문제2: 개 타입 반환, 캐스팅 필요
        dogHospital.set(dog);
        Dog biggerDog = (Dog) dogHospital.getBigger(new Dog("멍멍이2", 200));
        System.out.println("biggerDog = " + biggerDog);
    }
}
```
#### 실행 결과
```text
동물 이름: 멍멍이1
동물 크기: 100
멍멍
동물 이름: 냐옹이1
동물 크기: 300
야옹
biggerDog = Animal{name='멍멍이2', size=200}
```

### 문제
1. 코드 재사용 O
   - 다형성을 통해 `AnimalHospitalV1` 하나로 개와 고양이를 모두 처리한다.
2. 타입 안전성 X
   - 개 병원에 고양이를 전달하는 문제가 발생한다.
   - `Animal` 타입을 반환하기 때문에 다운 캐스팅을 해야 한다.
   - 실수로 고양이를 입력했는데, 개를 반환하는 상황이면 캐스팅 예외가 발생한다.

## 타입 매개변수 제한3 - 제네릭 도입과 실패
이제 앞서 배운 제네릭을 도입해서 코드 재사용은 늘리고, 타입 안전성 문제도 해결해보자.

### [AnimalHospitalV2](..%2Fsrc%2Fgeneric%2Fex3%2FAnimalHospitalV2.java)
```java
public class AnimalHospitalV2<T> {

    private T animal;

    public void set(T animal) {
        this.animal = animal;
    }

    public void checkup() {
        // T의 타입을 메서드를 정의하는 시점에 알 수 없다. Object 기능만 사용 가능하다.
        animal.toString();
        animal.equals(null);
        
        // 컴파일 오류
        // System.out.println("동물 이름: " + animal.getName());
        // animal.sound();
    }

    public T getBigger(T target) {
        // 컴파일 오류
        // return animal.getSize() > target.getSize() ? animal : target;
        return null;
    }
}
```
- `<T>`를 사용해서 제네릭 타입을 선언했다.
- 제네릭 타입을 선언하면 자바 컴파일러 입장에서 `T`에 어떤 값이 들어올지 예측할 수 없다. 우리는 `Animal` 타입의 자식이 들어오기를 기대했지만,
여기 코드 어디에도 `Animal`에 대한 정보는 없다. `T`에는 타입 인자로 `Integer`가 들어올 수도 있고, `Dog`rㅏ 들어올 수도 있다. 물론 `Object`가 들어올 수도 있다.

### 다양한 타입 인자
```java
AnimalHospitalV2<Dog> dogHospital = new AnimalHospitalV2<>();
AnimalHospitalV2<Cat> catHospital = new AnimalHospitalV2<>();
AnimalHospitalV2<Integer> integerHospital = new AnimalHospitalV2<>();
AnimalHospitalV2<Object> objectHospital = new AnimalHospitalV2<>();
```
자바 컴파일러는 어떤 타입이 들어올 지 알 수 없기 때문에 `T`를 어떤 타입이든 받을 수 있는 모든 객체의 최종 부모인 `Object`가 제공하는 메서드만 호출할 수 있다.  
원하는 기능을 사용하려면 `Animal` 타입이 제공하는 기능들이 필요한데, 이 기능을 모두 사용할 수 없다.

여기에 추가로 한가지 문제가 더 있다. 바로 동물 병원에 `Integer`, `Object` 같은 동물과 전혀 관계 없는 타입을 타입인자로 전달할 수 있다는 점이다.
우리는 최소한 `Animal`이나 그 자식 타입인자로 제한하고 싶다.

### [AnimalHospitalMainV2](..%2Fsrc%2Fgeneric%2Fex3%2FAnimalHospitalMainV2.java)
```java
public class AnimalHospitalMainV2 {

    public static void main(String[] args) {
        AnimalHospitalV2<Dog> dogHospital = new AnimalHospitalV2<>();
        AnimalHospitalV2<Cat> catHospital = new AnimalHospitalV2<>();
        AnimalHospitalV2<Integer> integerHospital = new AnimalHospitalV2<>();
        AnimalHospitalV2<Object> objectHospital = new AnimalHospitalV2<>();
    }
}
```

#### 문제
- 제네릭에서 타입 매개변수를 사용하면 어떤 타입이든 들어올 수 있다.
- 따라서 타입 매개변수를 어떤 타입이든 수용할 수 있는 `Object`로 가정하고, `Object`의 기능만 사용할 수 있다.

발생한 문제들을 생각해보면 타입 매개변수를 `Animal`로 제한하지 않았기 때문이다. 만약 타입 인자가 모두 `Animal`과 그 자식들만 들어올 수 있게 제한한다면 어떨까?

## 타입 매개변수 제한4 - 타입 매개변수 제한
타입 매개변수를 특정 타입으로 제한할 수 있다.
### [AnimalHospitalV3](..%2Fsrc%2Fgeneric%2Fex3%2FAnimalHospitalV3.java)
```java
public class AnimalHospitalV3<T extends Animal> {
    private T animal;

    public void set(T animal) {
        this.animal = animal;
    }

    public void checkup() {
        System.out.println("동물 이름: " + animal.getName()); 
        System.out.println("동물 크기: " + animal.getSize());
        animal.sound();
    }
    
    public T getBigger(T target) {
        return animal.getSize() > target.getSize() ? animal : target;
    }
}
```
여기서 핵심은 `<T extends Animal>`이다.

타입 매개변수 `T`를 `Animal`과 그 자식만 받을 수 있도록 제한을 두는 것이다. 즉, `T`의 상한이 `Animal`이 되는 것이다.

이렇게하면 타입 인자로 들어올 수 있는 값이 `Animal`과 그 자식으로 제한된다.
```java
AnimalHospitalV3<Animal>
AnimalHospitalV3<Dog>
AnimalHospitalV3<Cat>
```
이제 자바 컴파일러는 `T`에 입력된 수 있는 값의 범위를 예측할 수 있다.

타입 매개변수 `T`에는 타입 인자로 `Animal`, `Dog`, `Cat`만 들어올 수 있다. 따라서 이를 모두 수용할 수 있는 `Animal`을 `T` 타입으로 가정해도 문제가 없다.

따라서 `Animal`이 제공하는 `getName()`, `getSize()` 같은 기능을 사용할 수 있다.

### [AnimalHospitalMainV3](..%2Fsrc%2Fgeneric%2Fex3%2FAnimalHospitalMainV3.java)
```java
public class AnimalHospitalMainV3 {

    public static void main(String[] args) {
        AnimalHospitalV3<Dog> dogHospital = new AnimalHospitalV3<>();
        AnimalHospitalV3<Cat> catHospital = new AnimalHospitalV3<>();
        Dog dog = new Dog("멍멍이1", 100);
        Cat cat = new Cat("냐옹이1", 300);

        // 개 병원
        dogHospital.set(dog); dogHospital.checkup();
        // 고양이 병원
        catHospital.set(cat); catHospital.checkup();

        // 문제1 해결: 개 병원에 고양이 전달
        // dogHospital.set(cat); // 다른 타입 입력: 컴파일 오류

        // 문제2 해결: 개 타입 반환
        dogHospital.set(dog);
        Dog biggerDog = dogHospital.getBigger(new Dog("멍멍이2", 200));
        System.out.println("biggerDog = " + biggerDog);
    }
}
```

#### 실행 결과
```text
동물 이름: 멍멍이1
동물 크기: 100
멍멍
동물 이름: 냐옹이1
동물 크기: 300
야옹
biggerDog = Animal{name='멍멍이2', size=200}
```
타입 매개변수에 입력될 수 있는 상한을 지정해서 문제를 해결했다.
- `AnimalHospitalV3<Integer>`와 같이 동물과 전혀 관계없는 타입 인자를 컴파일 시점에 막는다.
- 제네릭 클래스 안에서 `Animal`의 기능을 사용할 수 있다.

### 기존 문제와 해결
- 타입 안전성 문제
  - 개 병원에 고양이를 전달하는 문제가 발생한다. ➡️ 해결
  - `Animal` 타입을 반환하기 때문에 다운 캐스팅을 해야 한다. ➡️ 해결
  - 실수로 고양이를 입력했는데, 개를 반환하는 상황이라면 캐스팅 예외가 발생한다. ➡️ 해결
- 제네릭 도입 문제
  - 제네릭에서 타입 매개변수를 사용하면 어떤 타입이든 들어올 수 있다. ➡️ 해결
  - 어떤 타입이든 수용할 수 있는 `Object`로 가정하고, `Object`의 기능만을 사용할 수 있다. ➡️ 해결
    - 여기서는 `Animal`을 상한으로 두어서 `Animal`의 기능을 사용할 수 있다.

### 정리
제네릭에 **타입 매개변수 상한**을 사용해서 타입 안전성을 지키면서 상위 타입의 원하는 기능까지 사용할 수 있었다.
덕분에 코드 재사용과 타입 안전성이라는 두 마리 토끼를 동시에 잡을 수 있었다.

## 제네릭 메서드
이번에는 특정 메서드에 제네릭을 적용하는 제네릭 메서드에 대해 알아보자.

참고로, 앞서 살펴본 제네릭 타입과 지금부터 살펴볼 제네릭 메서드는 둘다 제네릭을 사용하긴 하지만 서로 다른 기능을 제공한다.
### [GenericMethod](..%2Fsrc%2Fgeneric%2Fex4%2FGenericMethod.java)
```java
public class GenericMethod {

    public static Object objMethod(Object obj) {
        System.out.println("obj = " + obj);
        return obj;
    }

    public static <T> T genericMethod(T t) {
        System.out.println("generic print = " + t);
        return t;
    }

    public static <T extends Number> T numberMethod(T t) {
        System.out.println("bound print = " + t);
        return t;
    }
}
```

### [MethodMain1](..%2Fsrc%2Fgeneric%2Fex4%2FMethodMain1.java)
```java
public class MethodMain1 {

    public static void main(String[] args) {
        Integer i = 10;
        Object object = GenericMethod.objMethod(i);
        
        // 타입 인자 (Type Argument) 명시적 전달
        System.out.println("명시적 타입 인자 전달");
        Integer result = GenericMethod.<Integer>genericMethod(i);
        Integer integerValue = GenericMethod.<Integer>numberMethod(10);
        Double doubleValue = GenericMethod.<Double>numberMethod(20.0);
    }
}
```

#### 실행 결과
```text
obj = 10
명시적 타입 인자 전달
generic print = 10
bound print = 10
bound print = 20.0
```

### 제네릭 타입
- 정의: `GenericClass<T>`
- 타입 인자 전달: 객체를 생성하는 시점
  - 예) `new GenericClass<String>`

### 제네릭 메서드
- 정의: `<T> T genericMethod(T t)`
- 타입 인자 전달: 메서드를 호출하는 시점
  - 예) `GenericMethod.<Integer>genericMethod(i)`
- 제네릭 메서드는 클래스 전체가 아니라 특정 메서드 단위로 제네릭을 도입할 때 사용한다.
- 제네릭 메서드를 정의할 때는 메서드의 반환 타입 왼쪽에 다이아몬드를 사용해서 `<T>`와 같이 매개변수를 적어준다.
- 제네릭 메서드는 메서드를 실제 호출하는 시점에 타입 인자를 전닳서 타입을 지정하는 것이다. 따라서 타입을 지정하면서 메서드를 호출한다.

### 인스턴스 메서드, static 메서드
제네릭 메서드는 인스턴스 메서드와 static 메서드에 모두 적용할 수 있다.
```java
class Box<T> { 
    static <V> V staticMethod2<V t> {}  // static 메서드에 제네릭 메서드 도입
    <Z> Z instanceMethod2(Z z) {}       // 인스턴스 메서드에 제네릭 메서드 도입
}
```

> 🍀 제네릭 타입은 static 메서드에 타입 매개변수를 사용할 수 없다. 제네릭 타입은 객체를 생성하는 시점에 타입이 정해진다.
> 그런데 static 메서드는 인스턴스 단위가 아니라 클래스 단위로 작동하기 때문에 제네릭 타입과는 무곤하다. 따라서 static 메서드에 제네릭을 도입하려면 제네릭 메서드를 사용해야 한다.
> ```java
> class Box<T> {
>       T instanceMethod(T t) {} // 가능
>       static T staticMethod1(T t) {} // 제네릭 타입의 T 사용 불가능
> }
> ```

### 타입 매개변수 제한
제네릭 메서드도 제네릭 타입과 마찬가지로 타입 매개변수를 제한할 수 있다.
다음 코드는 타입 매개변수를 `Number`로 제한했다. 따라서 `Number`와 그 자식만 받을 수 있다.

참고로 `Integer`, `Double`, `Long`과 같은 숫자 타입이 `Number`의 자식이다.

```java
public static <T extends Number> T numberMethod(T t) { }
```
```java
// GenericMethod.numberMethod("Hello"); // 컴파일 오류, Number의 자식만 입력 가능
```

### 제네릭 매서드 타입 추론
제네릭 메서드를 호출할 때 `<Integer>`와 같이 타입 인자를 게속 전달하는 것은 매우 불편하다.
```java
Integer i = 10;
Integer result = GenericMethod.<Integer>genericMethod(i);
```
자바 컴파일러는 `genericMethod()`에 전달되는 인자 `i`의 타입이 `Integer`라는 것을 알 수 있다.
또한 반환 타입이 `Integer result`라는 것도 알 수 있다. 이런 정보를 통해 자바 컴파일러는 타입 인자를 추론할 수 있다.

앞서 만든 `MethodMain1`에 다음 코드를 추가해서 실행해보자.
#### [MethodMain1](..%2Fsrc%2Fgeneric%2Fex4%2FMethodMain1.java)
```java
// 타입 추론, 타입 인자 생략
System.out.println("타입 추론");
Integer integer2 = GenericMethod.genericMethod(i);
Integer integerValue2 = GenericMethod.numberMethod(10);
Double doubleValue2 = GenericMethod.numberMethod(20.0);
```

##### 실행 결과
```text
타입 추론
generic print = 10
bound print = 10
bound print = 20.0
```

타입 추론 덕분에 타입 인자를 직접 전달하는 불편함이 줄어든다. 이 경우 타입을 추론해서 컴파일러가 대신 처리하기 때문에 전달하지 않는 것 처럼보인다.
하지만 실제로는 타입 인자가 전달된다는 것을 기억하자

## 제네릭 메서드 활용
앞서 **제네릭 타입**으로 만들었던 `AnimalHospitalV3`의 주요 기능을 **제네릭 메서드**로 다시 만들어보자.

### [AnimalMethod](..%2Fsrc%2Fgeneric%2Fex4%2FAnimalMethod.java)
```java
public class AnimalMethod {

    public static <T extends Animal> void checkup(T t) {
        System.out.println("t.getName() = " + t.getName());
        System.out.println("t.getSize() = " + t.getSize());
        t.sound();
    }

    public static <T extends Animal> T getBigger(T t1, T t2) {
        return t1.getSize() > t2.getSize() ? t1: t2;
    }
}
```
- `checkup()`, `getBigger()`라는 두 개의 제네릭 메서드를 정의했다. 둘 다 `Animal`을 상한으로 제한한다.

### [MethodMain2](..%2Fsrc%2Fgeneric%2Fex4%2FMethodMain2.java)
```java
public class MethodMain2 {

    public static void main(String[] args) {
        Dog dog = new Dog("멍멍이", 100);
        Cat cat = new Cat("냐옹이", 100);

        AnimalMethod.checkup(dog);
        AnimalMethod.checkup(cat);

        Dog targetDog = new Dog("큰 멍멍이", 200);
        Dog bigger = AnimalMethod.getBigger(dog, targetDog);
        System.out.println("bigger = " + bigger);
    }
}
```

### 제네릭 타입과 제네릭 메서드의 우선순위
정적 메서드는 제네릭 메서드만 적용할 수 있지만, 인스턴스 메서드는 제네릭 타입도 제네릭 메서드도 둘다 적용할 수 있다.  
여기에 제네릭 타입과 제네릭 메서드의 타입 매개변수를 같은 이름으로 사용하면 어떻게 될까?

### [ComplexBox](..%2Fsrc%2Fgeneric%2Fex4%2FComplexBox.java)
```java
public class ComplexBox<T extends Animal> {

    private T animal;

    public void set(T animal) {
        this.animal = animal;
    }
    public <T> T printAndReturn(T t) {
        System.out.println("animal.className: " + animal.getClass().getName());
        System.out.println("t.className: " + t.getClass().getName());

        // t.getName(); // 호출 불가 메서드는 <T> 타입이다. <T extends Animal> 타입이 아니다.
        return t;
    }
}
```
### [MethodMain3](..%2Fsrc%2Fgeneric%2Fex4%2FMethodMain3.java)
```java
public class MethodMain3 {

    public static void main(String[] args) {
        Dog dog = new Dog("멍멍이", 100);
        Cat cat = new Cat("냐옹이", 50);

        ComplexBox<Dog> hospital = new ComplexBox<>();
        hospital.set(dog);

        Cat returnCat = hospital.printAndReturn(cat);
        System.out.println("returnCat = " + returnCat);
    }
}
```

#### 실행 결과
```text
animal.className: generic.animal.Dog
t.className: generic.animal.Cat
returnCat = Animal{name='냐옹이', size=50}
```

- 제네릭 타입 설정
```java
class Complex<T extends Animal>
```
- 제네릭 메서드 설정
```java
<T> T printAndReturn(T t)
```

제네릭 타입보다 제네릭 메서드가 높은 우선순위를 갖는다.

따라서 `printAndReturn()`은 제네릭 타입과는 무관하고 제네릭 메서드가 적용된다.

여기서 적용된 제네릭 메서드의 타입 매개변수 `T`는 상한이 없다. 따라서 `Object`로 취급된다.
`Object`로 취급되기 때문에 `t.getName()`과 같은 `Animal`에 존재하는 메서드는 호출할 수 없다.

참고로 프로그래밍에서 이렇게 모호한 것은 좋지않다.
둘의 이름이 겹치면 다음과 같이 둘중 하나를 다른 이름으로 변경하는 것이 좋다.
```java
public class ComplexBox<T extends Animal> {
     private T animal;
     
     public void set(T animal) {
         this.animal = animal;
     }
    
     public <Z> Z printAndReturn(Z z) {
         //...
     }
}
```

## 와일드카드
이번에는 제네릭 타입을 조금 더 편리하게 사용할 수 있는 와일드카드에 대해 알아본다.
> 🍀 와일드카드란?  
> 컴퓨터 프로그래밍에서 `*`, `?`와 같이 하나 이상의 문자들을 상징하는 특수 문자를 뜻한다. 쉽게 이야기해서 여러 타입이 들어올 수 있다는 뜻이다.

### [Box](..%2Fsrc%2Fgeneric%2Fex5%2FBox.java)
```java
public class Box<T> {
    
    private T value;

    public void set(T value) {
        this.value = value;
    }

    public T get() {
        return value;
    }
}
```
- 단순히 데이터를 넣고 반환할 수 있는 제네릭 타입

### [WildcardEx](..%2Fsrc%2Fgeneric%2Fex5%2FWildcardEx.java)
```java
public class WildcardEx {

    static <T> void printGenericV1(Box<T> box) {
        System.out.println("T = " + box.get());
    }

    static void printWildcardV1(Box<?> box) {
        System.out.println("? = " + box.get());
    }

    static <T extends Animal> void printGenericV2(Box<T> box) {
        T t = box.get();
        System.out.println("이름 = " + t.getName());
    }

    static void printWildcardV2(Box<? extends Animal> box) {
        Animal animal = box.get();
        System.out.println("이름 = " + animal.getName());
    }
    static <T extends Animal> T printAndReturnGeneric(Box<T> box) {
        T t = box.get();
        System.out.println("이름 = " + t.getName());
        return t; }

    static Animal printAndReturnWildcard(Box<? extends Animal> box) {
        Animal animal = box.get();
        System.out.println("이름 = " + animal.getName());
        return animal;
    }
}
```

### [WildCardMain1](..%2Fsrc%2Fgeneric%2Fex5%2FWildCardMain1.java)
```java
public class WildCardMain1 {

    public static void main(String[] args) {
        Box<Object> objBox = new Box<>();
        Box<Dog> dogBox = new Box<>();
        Box<Cat> catBox = new Box<>();
        dogBox.set(new Dog("멍멍이", 100));

        WildcardEx.printGenericV1(dogBox);
        WildcardEx.printWildcardV1(dogBox);
        WildcardEx.printGenericV2(dogBox);
        WildcardEx.printWildcardV2(dogBox);

        Dog dog = WildcardEx.printAndReturnGeneric(dogBox);
        Animal animal = WildcardEx.printAndReturnWildcard(dogBox);
    }
}
```

#### 실행 결과
```text
T = Animal{name='멍멍이', size=100} ? = Animal{name='멍멍이', size=100} 이름 = 멍멍이
이름 = 멍멍이
이름 = 멍멍이
이름 = 멍멍이
```

> 🍀 와일드 카드는 제네릭 타입이나, 제네릭 메서드를 선언하는 것이 아니다. 와일드카드는 이미 만들어진 제네릭 타입을 활용할 때 사용한다.

#### 비 제한 와일드 카드
```java
//이것은 제네릭 메서드이다.
//Box<Dog> dogBox를 전달한다. 타입 추론에 의해 타입 T가 Dog가 된다. 
static <T> void printGenericV1(Box<T> box) {
     System.out.println("T = " + box.get());
}

//이것은 제네릭 메서드가 아니다. 일반적인 메서드이다.
//Box<Dog> dogBox를 전달한다. 와일드카드 ?는 모든 타입을 받을 수 있다.
static void printWildcardV1(Box<?> box) {
     System.out.println("? = " + box.get());
}
```
- 두 메서드는 비슷한 기능을 제공하는 코드이다. 하나는 제네릭 메서드를 사용하고, 하나는 일반적인 메서드에 와일드카드를 사용했다.
- 와일드카드는 제네릭 타입이나 제네릭 메서드를 정의할 때 사용하는 것이 아니다. `Box<Dog>`, `Box<Cat>` 처럼 타입 인자가 정해진 제네릭 타입을 전달받아서 활용할 때 사용한다.
- 와일드카드인 `?`는 모든 타입을 다 받을 수 있다는 뜻이다.
  - 다음과 같이 해석할 수 있다. `? == <? extends Object>`
- 이렇게 `?`만 사용해서 제한 없이 모든 타입을 다 받을 수 있는 와일드 카드를 **비 제한 와일드 카드**라고 한다.
  - 여기에서 `Box<Dog> dogBox`, `Box<Cat> catBox`, `Box<Object> objBox`가 모두 입력될 수 있다.
#### 제네릭 메서드 실행 예시
```java
//1. 전달
printGenericV1(dogBox)

//2. 제네릭 타입 결정 dogBox는 Box<Dog> 타입, 타입 추론 -> T의 타입은 Dog
static <T> void printGenericV1(Box<T> box) {
     System.out.println("T = " + box.get());
}

//3. 타입 인자 결정
static <Dog> void printGenericV1(Box<Dog> box) {
  System.out.println("T = " + box.get());
}

//4. 최종 실행 메서드
static void printGenericV1(Box<Dog> box) {
  System.out.println("T = " + box.get());
}
```

#### 와일드 카드 실행 예시
```java
//1. 전달
printWildcardV1(dogBox)

//이것은 제네릭 메서드가 아니다. 일반적인 메서드이다.
//2. 최종 실행 메서드, 와일드카드 ?는 모든 타입을 받을 수 있다.
static void printWildcardV1(Box<?> box) {
     System.out.println("? = " + box.get());
}
```

### 제네릭 메서드 vs 와일드 카드
`printGenericV1()` 제네릭 메서드를 보자. 제네릭 메서드에는 타입 매개변수가 존재한다. 그리고 특정 시점에 타입 매개변수에 타입 인자를 전달해서 타입을 결정해야 한다.
이런 과정을 매우 복잡하다.

반면에 `printWildcardV1()`메서드를 보자. 와일드카드는 일반적인 메서드에 사용할 수 있고, 단순히 매개변수로 제네릭 타입을 받을 수 있는 것 뿐이다.
제네릭 메서드처럼 타입을 결정하거나 복잡하게 작동하지 않는다. 단순히 일반 메서드에 제네릭 타입을 받을 수 있는 매개벼수가 하나 있는 것 뿐이다.

제네릭 타입이나 제네릭 메서드를 정의하는 게 꼭 필요한 상황이 아니라면, 더 단순한 와일드카드 사용을 권장한다.

### 상한 와일드 카드
```java
static <T extends Animal> void printGenericV2(Box<T> box) {
    T t = box.get();
    System.out.println("이름 = " + t.getName());
}

static void printWildcardV2(Box<? extends Animal> box) {
    Animal animal = box.get();
    System.out.println("이름 = " + animal.getName());
}
```
- 제네릭 메서드와 마찬가지로 와일드카드에도 상한 제한을 둘 수 있다.
- 여기서는 `? extends Animal`을 지정했다.
- `Animal`과 그 하위 타입만 입력받는다.
- `box.get()`을 통해서 꺼낼 수 있는 타입의 최대 부모는 `Animal`이 된다. 따라서 `Animal` 타입으로 조회할 수 있다.
- 결과적으로 `Animal`타입의 기능을 호출 할 수 있다.

### 타입 매개변수가 꼭 필요한 경우
와일드 카드는 제네릭을 정의할 때 사용하는 것이 아니다. `Box<Dog>`, `Box<Cat>` 처럼 타입 인자가 전달된 제네릭 타입을 활용할 때 사용한다. 따라서 다음과 같은 경우에는 제네릭 타입이나 제네릭 메서드를 사용해야 문제를 해결할 수 있다.
```java
```java
static <T extends Animal> T printAndReturnGeneric(Box<T> box) {
    T t = box.get();
    System.out.println("이름 = " + t.getName());
    return t; 
}

static Animal printAndReturnWildcard(Box<? extends Animal> box) { 
    Animal animal = box.get();
    System.out.println("이름 = " + animal.getName());
    return animal;
}
```

`printAndReturnGeneric()`은 다음과 같이 전달한 타입을 명확하게 반환할 수 있다.
```java
Dog dog = WildcardEx.printAndReturnGeneric(dobBox);
```

반면에 `printAndReturnWildcard()`의 경우 전달한 타입을 명확하게 반환할 수 없다. 여기서는 `Animal`타입으로 반환한다.
```java
Animal animal = WildcardEx.printAndReturnWildcard(dogBox);
```

메서드의 타입들을 특정 시점에 변경하려면 제네릭 타입이나, 제네릭 메서드를 사용해야 한다.
와일드카드는 이미 만들어진 제네릭 타입을 전달 받아서 활용할 때 사용한다. 따라서 메서드의 타입들을 타입 인자를 통해 변경할 수 없다.
쉽게 이야기해서 일반적인 메서드에 사용한다고 생각하면 된다.

정리하면 제네릭 타입이나 제네릭 메서드가 꼭 필요한 상황이면 `<T>`를 사용하고, 그렇지 않은 상황이면 와일드카드를 사용하는 것을 권장한다.


### 하한 와일드카드
와일드카드는 상한 뿐만 아니라 하한도 지정할 수 있다.
#### [WildCardMain2](..%2Fsrc%2Fgeneric%2Fex5%2FWildCardMain2.java)
```java
public class WildCardMain2 {

    public static void main(String[] args) {
        Box<Object> objBox = new Box<>();
        Box<Animal> animalBox = new Box<>();
        Box<Dog> dogBox = new Box<>();
        Box<Cat> catBox = new Box<>();
        dogBox.set(new Dog("멍멍이", 100));

        // Animal 포함 상위 타입 전달 가능
        writeBox(objBox);
        writeBox(animalBox);

        // writeBox(dogBox); // 하한이 Animal
        // writeBox(catBox); // 하한이 Animal

        Animal animal = animalBox.get();
        System.out.println("animal = " + animal);
    }

    static void writeBox(Box<? super Animal> box) {
        box.set(new Dog("멍멍이", 100));
    }
}
```

##### 실행 결과
```text
animal = Animal{name='멍멍이', size=100}
```


```java
Box<? extends Animal> box
```
이 코드는 `?`가 `Animal` 타입을 포함한 `Animal` 타입의 상위 타입만 입력받을 수 있다는 뜻이다.

정리하면 다음과 같다.

|                       | 허용/불가 |
|-----------------------|-------|
| Box<Object> objBox    | 허용    |
| Box<Animal> animalBox | 허용    |
| Box<Dog> dogBox       | 불가    |
| Box<Cat> catBox       | 불가    |

하한을 `Animal`로 제한했기 때문에 `Animal`의 하위 타입인 `Box<Dog>`는 전달할 수 없다.

## 타입 이레이저
이레이저(eraser)는 지우개라는 뜻이다.

제네릭은 자바 컴파일 단계에서만 사용되고, 컴파일 이후에는 제네릭 정보가 삭제된다. 제네릭에서 사용한 타입 매개변수가 모두 사라지는 것이다.
쉽게 이야기해서 컴파일 전인 `.java`에서는 제네릭의 매개변수가 존재하지만, 컴파일 이후인 자바 바이트코드 `.class`에는 타입 매개변수가 존재하지 않는 것이다.

### 제네릭 타입 선언
#### [GenericBox](..%2Fsrc%2Fgeneric%2Fex1%2FGenericBox.java)
```java
public class GenericBox<T> {

    private T value;

    public void set(T value) {
        this.value = value;
    }

    public T get() {
        return value;
    }
}
```

```java
void main() {
    GenericBox<Integer> box = new GenericBox<Integer>();
    box.set(10);
    Integer result = box.get();
}
```

이렇게 하면 자바 컴파일러는 컴파일 시점에 타입 매개변수와 타입 인자를 포함한 제네릭 정보를 활용해서 `new GenericBox<Integer>()`에 대해 다음과 같이 이해한다.
```java
public class GenericBox<Integer> {
    private Integer value;

    public void set(Integer value) {
        this.value = value;
    }
  
    public Integer get() {
        return value;
    }
}
```

컴파일이 모두 끝나면 자바는 제네릭과 관련된 정보를 삭제한다. 이 때, `.class`에 생성된 정보는 다음과 같다.
```java
public class GenericBox {
    private Object value;

    public void set(Object value) {
        this.value = value;
    }
  
    public Object get() {
        return value;
    }
}
```
상한 제한 없이 선언한 타입 매개변수 `T`는 `Object`로 변환된다.

```java
void main() {
    GenericBox box = new GenericBox();
    box.set(10);
    Integer result = (Integer) box.get(); // 컴파일러가 캐스팅 추가
}
```
값을 반환 받는 부분은 `Object`로 받으면 안된다. 자바 컴파일러는 제네릭에서 타입 인자로 지정한 `Integer`로 캐스팅 하는 코드를 추가해준다.  
이렇게 추가된 코드는 자바 컴파일러가 이미 검증하고 추가했기 때문에 문제가 발생하지 않는다.

### 타입 매개변수 제한의 경우
다음과 같이 타입 매개변수를 제한하면 제한한 타입으로 코드를 변경한다.

#### 컴파일 전

```java
public class AnimalHospitalV3<T extends Animal> {
    private T animal;
  
    public void set(T animal) {
        this.animal = animal;
    }
  
    public void checkup() {
        System.out.println("동물 이름: " + animal.getName());
        System.out.println("동물 크기: " + animal.getSize());
        animal.sound();
    }
  
    public T getBigger(T target) {
        return animal.getSize() > target.getSize() ? animal : target;
    }
}
```

```java
AnimalHospitalV3<Dog> hospital = new AnimalHospitalV3<Dog>();

...

Dog dog = animalHospitalV3.getBigger(new Dog());
```

#### 컴파일 후
```java
public class AnimalHospitalV3 {
    private Animal animal;
    
    public void set(Animal animal) {
        this.animal = animal;
    }
    
    public void checkup() {
        System.out.println("동물 이름: " + animal.getName()); 
        System.out.println("동물 크기: " + animal.getSize());
        animal.sound();
    }
    
    public Animal getBigger(Animal target) {
        return animal.getSize() > target.getSize() ? animal : target;
    }
}
```
`T`의 타입 정보가 제거되어도 상한으로 지정한 `Animal` 타입으로 대체되기 때문에 `Animal` 타입의 메서드를 사용하는데는 아무런 문제가 없다.

```java
AnimalHospitalV3 hotpital = new AnimalHospitalV3();
...
Dog dog = (Dog) animalHospotalV3.getBigger(new Dog());
```

자바의 제네릭은 단순하게 생각하면 개발자가 직접 캐스팅하는 코드를 컴파일러가 대신 처리해주는 것이다. 자바는 컴파일 시점에 제네릭을 사용한 코드에 문제가 없는지 완벽하게
검증하기 때문에 자바 컴파일러가 추가하는 다운 캐스팅에는 문제가 발생하지 않는다.
자바의 제네릭 타입은 컴파일 시점에만 존재하고, 런타임 시에는 제네릭 정보가 지워지는데, 이것을 타입 이레이저라고 한다.

### 타입 이레이저 방식의 한계
컴파일 이후에는 제네릭의 타입 정보가 존재하지 않는다. `.class`로 자바를 실행하는 런타임에는 우리가 지정한 `Box<Integer>`, `Box<String>`의 타입정보가 모두 제거된다.

따라서 런타임에 타입을 활용하는 다음과 같은 코드는 작성할 수 있다.
```java
class EraserBox<T> {
    public boolean instanceCheck(Object param) { 
        return param instanceof T; // 오류
    }
    
    public void create() {
        return new T(); // 오류
    } 
}
```

```java
class EraserBox {
    public boolean instanceCheck(Object param) { 
        return param instanceof Object; // 오류
    }
    
    public void create() {
        return new Object(); // 오류
    }
}
```
- 여기서 `T`는 런타임에 모두 `Object`가 되어버린다.
- `instanceof`는 항상 `Object`와 비교하게 된다. 이렇게되면 항상 참이반환되는 문제가 발생한다. 자바는 이런 문제 때문에 타입 매개변수에 `instanceof`를 허용하지 않는다.
- `new T`는 항상 `new Object`가 되어버린다. 개발자가 의도한 것과는 다르다. 따라서 자바는 타입 매개변수에 `new`를 허용하지 않는다.

## 정리
실무에서 직접 제네릭을 사용해서 무언가를 설계하거나 만드는 일은 드물다. 그것보다는 대부분 이미 제네릭을 통해 만들어진 프레임워크나 라이브러리들을 가져다가 사용하는 경우가 훨씬 많다.

그래서 이미 만들어진 코드의 제네릭을 읽고 이해하는 정보면 충분하다. 실무에서 직접 제네릭을 사용하더라도 어렵고 복잡하게 사용하기 보다는 보통 단순하게 사용한다.

지금까지 학습한 정도면 실무에 필요한 제네릭은 충분히 이해했다고 볼 수 있다.

제네릭은 지금까지 설명한 내용보다 더 복잡하고 어려운 개념들도 있다. 특히 공변, 반공변과 같은 개념들이 그러하다. 이런 개념들을 이해하면 와일드카드가 존재하는 이유도 깊게 알 수 있다.

하지만, 제네릭을 사용해서 매우 복잡한 라이브러리나 프레임워크를 직접 설계하지 않는 이상 이런 개념들을 꼭 이해할 필요는 없다. 
이런 부분은 실무에서 많은 경험을 쌓고 본인이 필요하다고 느껴질 때 따로 공부하는 것을 권장한다.

제네릭은 이후에 설명하는 컬렉션 프레임워크에서 가장 많이 사용된다. 따라서 컬렉션 프레임워크를 통해서 제네릭이 어떻게 활용되는지 자연스럽게 학습할 수 있다.