# 1. Object 클래스

---
## java.lang 패키지 소개
자바가 기본으로 제공하는 라이브러리(클래스 모음) 중에 가장 기본이 되는 것이 바로 `java.lang` 패키지이다.
여기서 `lang`은 `Language`(언어)의 줄임말이다.  
즉, 자바 언어를 이루는 가장 기본이 되는 클래스들을 보관하는 패키지를 뜻한다.

### java.lang 패키지의 대표적인 클래스들
- `Object`: 모든 자바 객체의 부모 클래스
- `String`: 문자열
- `Integer`, `Long`, `Double`: 래퍼 타입, 기본형 데이터 타입을 객체로 만든 것 
- `Class`: 클래스 메타 정보
- `System`: 시스템과 관련된 기본 기능

위의 클래스들은 자바 언어의 기본을 이룬다.

### import 생략 기능
`java.lang` 패키지는 모든 자바 애플리케이션에 자동으로 `import`된다. 따라서 임포트 구문을 사용하지 않아도 된다.

다른 패키지에 있는 클래스를 사용하려면 다음과 같이 import 해야 한다.
```java
package lang;

import java.lang.System;

public class LangMain {
    
    public static void main(String[] args) {
        System.out.println("hello java");
    }
}
```

`System`클래스는 `java.lang` 패키지 소속이다. 따라서 아래와 같이 import를 생략할 수 있다.
```java
package lang;

public class LangMain {

    public static void main(String[] args) {
        System.out.println("hello java");
    }
}
```
- `import java.lang.System;` 코드를 삭제해도 정상 동작한다.

---
## Object 클래스
자바에서 모든 클래스의 최상위 부모 클래스는 항상 `Object` 클래스다.
![Object Class.png](imgs%2FObject%20Class.png)
```java
package lang.object;

// 부모가 없으면 묵시적으로 Object 클래스를 상속받는다.
public class Parent {
    
    public void parentMethod() {
        System.out.println("Parent.parentMethod");
    } 
}
```

앞의 코드는 아래와 같다.
```java
package lang.object;

// extends Obejct 추가
public class Parent extends Object {
    
    public void parentMethod() {
        System.out.println("Parent.parentMethod");
    }
}
```
클래스에 상속 받을 부모 클래스가 없으면 묵시적으로 `Object` 클래스를 상속 받는다.

```java
package lang.object;

public class Child extends Parent {
    
    public void childMethod() {
        System.out.println("Child.childMethod");
    }
}
```
클래스에 상속 받을 부모 클래스를 명시적으로 지정하면 `Object`를 상속받지 않는다.

> **묵시적 (Implicit) vs 명시적 (Explicit)**  
> 묵시적: 개발자가 코드에 직접 기술하지 않아도 시스템 또는 컴파일러에 의해 자동으로 수행되는 것
> 명시적: 개발자가 코드에 직접 기술해서 작동하는 것을 의미

```java
package lang.object;

public class ObjectMain {

    public static void main(String[] args) {
        Child child = new Child();
        child.childMethod();
        child.parentMethod();
        
        // toString()은 Object 클래스의 메서드
        String string = child.toString();
        System.out.println(string);
    }
}
```
`toString()`은 `Object`클래스의 메서드다. 이 메서드는 객체의 정보를 제공한다.

**실행결과**
```text
Child.childMethod
Parent.parentMethod
lang.object.Child@X001
```

**실행 결과 그림**
![toString().png](imgs%2FtoString%28%29.png)
`Parent`는 `Object`를 묵시적으로 상속받았기 때문에 메모리에도 함께 생성된다.
1. `child.toString()`을 호출한다.
2. 먼저 본인의 타입인 `Child`에서 `toString()`을 찾는다. 없으므로 부모 타입으로 올라가서 찾는다.
3. 부모 타입인 `Parent`에서 찾는다. 없으므로 부모 타입에서 찾는다.
4. 부모 타입인 `Object`에서 찾는다. `Object`에 `toString()`이 있으므로 이 메소드를 호출한다.

## 정리
🔥 **자바에서 모든 객체의 최종 부모는 `Object`다.** 

## 자바에서 Object 클래스가 최상위 부모 클래스인 이유
모든 클래스가 `Object`클래스를 상속받는 이유는 다음과 같다.

### 1. 공통 기능 제공
객체의 정보를 제공하고, 이 객체가 다른 객체와 같은지 비교하고, 객체가 어떤 클래스로 만들어졌는지 확인하는 기능은 모든 객체에게 필요한 기본 기능이다.
이런 기능을 객체를 만들 때 마다 항상 새로운 메서드를 정의해서 만들어야 한다면 상당히 번거로울 것이다.  
그리고 막상 만든다고 해도 개발자마다 서로 다른 이름의 메서드를 만들어서 일관성이 없을 것이다.  
`Object`는 모든 객체에 필요한 공통 기능을 제공한다. `Object`는 최상위 부모 클래스이기 때문에 모든 객체는 공통 기능을 편리하게 제공(상속) 받을 수 있다.

`Object`가 제공하는 기능
- 객체의 정보를 제공하는 `toString()`
- 객체의 같음을 비교하는 `equals()`
- 객체의 클래스 정보를 제공하는 `getClass()`
- 기타 여러가지 기능
이것들로 인해 프로그램이 단순화되고, 일관성을 가진다.

###  2. 다형성의 기본 구현
부모는 자식을 담을 수 있다. `Object`는 모든 클래스의 부모 클래스이기 때문에, 모든 객체를 참조할 수 있다.  
`Object`클래스는 다형성을 지원하는 기본적인 메커니즘을 제공한다. 모든 자바 객체는 `Object` 타입으로 처리될 수 있으며, 
이는 다양한 타입의 객체를 통합적으로 처리할 수 있게 해준다.  
즉, `Object`는 모든 객체를 다 담을 수 있다. 타입이 다른 객체들을 어딘가에 보관해야 한다면 바로 `Object`에 보관하면 된다.

---
## Object 다형성
`Object`는 모든 클래스의 부모 클래스이기 때문에 `Object`는 모든 객체를 참조할 수 있다.
![Object 다형성.png](imgs%2FObject%20%EB%8B%A4%ED%98%95%EC%84%B1.png)
`Dog`와 `Car`는 서로 관련이 없는 클래스다. 둘다 부모가 없기 때문에 `Object`를 자동으로 상속받는다.

```java
package lang.object.poly;

class Car {
    public void move() {
        System.out.println("자동차 이동");
    }
}
```

```java
package lang.object.poly;

class Dog {
    public void sound() {
        System.out.println("멍멍");
    }
}
```

```java
package lang.object.poly;

public class ObjectPolyExample1 {

    public static void main(String[] args) {
        Dog dog = new Dog();
        Car car = new Car();

        action(dog);
        action(car);
    }

    private static void action(Object object) {
//        object.sound(); 컴파일 오류, Object는 sound()가 없다.
//        object.move(); 컴파일 오류, Object는 move()가 없다.
        
        // 객체에 맞는 다운캐스팅 필요
        if (object instanceof Dog dog) {
            dog.sound();;
        } else if (object instanceof Car car) {
            car.move();
        }
        
    }
}
```

**실행 결과**
```text
멍멍
자동차 이동
```

`Object`는 모든 타입의 부모다. 부모는 자식을 담을 수 있기에 앞의 코드를 다음과 같이 변경해도 된다.
```java
Object dog = new Dog();
Object car = new Car();
```

### Object 다형성의 장점
`action(Object object)` 메서드를 분석해보자.  
이 메서드는 `Object` 타입의 매개변수를 사용한다. 그런데 `Object`는 모든 객체의 부모다. 따라서 어떤 객체든지 인자로 전달할 수 있다.
```java
action(dog) // main에서 dog 전달
void action(Object object = dog(Dog)) // Object는 자식인 Dog 타입을 참조할 수 있다.
```

```java
action(car) // main에서 car 전달
void action(Object object = car(Car)) // Object는 자식인 Car 타입을 참조할 수 있다.
```


### Object 다형성의 한계
```java
action(dog) // main에서 dog 전달
private static void action(Object object) {
    object.sound(); // 컴파일 오류, Object는 sound()가 없다.
}
```

`action()`메서드 안에서 `object.sound()`를 호출하면 오류가 발생한다. 왜나하면 매개변수인 `object`는 `Object`타입이기 때문이다. `Object`안에는 `sound()`메서드가 없다.
![Object 다형성 한계.png](imgs%2FObject%20%EB%8B%A4%ED%98%95%EC%84%B1%20%ED%95%9C%EA%B3%84.png)

#### object.sound() 호출
- `object.sound()`를 호출한다.
- `object`는 `Object`타입으로 `Object`타입에서 `sound()`를 찾는다.
- `Object`에서 `sound()`를 찾을 수 없다. `Object`는 최종 부모이므로 더 올라가서 찾을 수 없다. 따라서 오류가 발생한다.

`Dog` 인스턴스의 sound()를 호출하려면 다음과 같이 다운 캐스팅을 해야한다.
```java
if (object instanceof Dog dog) {
    dog.sound();
}
```
![다운캐스팅.png](imgs%2F%EB%8B%A4%EC%9A%B4%EC%BA%90%EC%8A%A4%ED%8C%85.png)
- `Object obj`의 참조값을 `Dog dog`으로 다운캐스팅 하면서 전달한다.
- `dog.sound()`를 호출하면 `Dog`타입에서 `sound()`를 찾아서 호출한다.

### Object를 활용한 다형성의 한계
- `Object`는 모든 객체를 대상으로 다형적 참조할 수 있다. `Object`는 모든 객체의 부모이므로 모든 객체를 담을 수 있다.
- `Object`를 통해 전달 받은 객체를 호출하려면 각 객체에 맞는 다운캐스팅 과정이 필요하다. 

다형성을 제대로 활용하려면 `다형적 참조 + 메서드 오버라이딩`을 함께 사용해야 한다. 그런면에서 `Object`를 사용한 다형성에는 한계가 있다.  
`Object`는 모든 객체의 부모이므로 모든 객체를 대상으로 다형적 참조를 할 수 있다. 
하지만 `Object`에는 `Dog.sound()`, `Car.move()`와 같은 다른 객체의 메서드가 정의되어 있지 않다. 따라서 메서드 오버라이딩을 활용할 수 없다.
결국 각 객체의 기능을 호출하려면 다운캐스팅을 해야한다.  
참고로 `Object` 본인이 보유한 `toString()` 같은 메서드는 당연히 자식 클래스에서 오버라이딩 할 수 있다.


## Object 배열
`Object`는 모든 타입의 객체를 담을 수 있다. 따라서 `Object[]`을 만들면 세상의 모든 객체를 담을 수 있는 배열을 만들 수 있다.
![Object 배열.png](imgs%2FObject%20%EB%B0%B0%EC%97%B4.png)

### `Object`가 없다면?
- `void action(Object obj)`와 같이 모든 객체를 받을 수 있는 메서드를 만들 수 없다.
- `Object[] objects`처럼 모든 객체를 저장할 수 있는 배열을 만들 수 없다.

물론 `Object`가 없어도 직접 `MyObject`와 같은 클래스를 만들고 모든 클래스에서 직접 정의한 `MyObject`를 상속받으면 된다.
하지만 하나의 프로젝트를 넘어서 전세계 모든 개발자가 비슷한 클래스를 만들 것이고. 서로 호환되지 않는 수많은 `XxxObject`들이 넘쳐날 것이다.


## toString()
`Object.toString()`메서드는 객체의 정보를 문자열 형태로 제공한다. 그래서 디버깅과 로깅에 유용하게 사용된다.
이 메서드는 `Object` 클래스에 정의되므로 모든 클래스에서 상속받아 사용할 수 있다.  
기본적으로 패키지를 포함한 객체의 이름과 객체의 참조값(해시코드)을 16진수로 제공한다.

### println()과 toString()
그런데 `toString()`의 결과를 출력한 코드와 `object`를 `println()`에 직접 출력한 코드의 결과가 완전히 같다.  
`System.out.println()`메서드는 내부에서 `toString()`을 호출하기 때문이다.  
`Object`타입(자식 포함)이 `println()`에 인수로 전달되면 내부에서 `obj.toString()`메서드를 호출해서 결과를 출력한다.  
따라서 `println()`을 사용할 때, `toString()`을 직접 호출할 필요 없이 객체를 바로 전달하면 객체의 정보를 출력할 수 있다.

### toString() 오버라이딩
`Object.toString()`메서드가 클래스 정보와 참조값을 제공하지만 이 정보만으로는 객체의 상태를 적절히 나타내지 못한다.
그래서 보통 `toString()`을 재정의(오버라이딩)해서 보다 유용한 정보를 제공하는 것이 일반적이다.
![toString() 재정의.png](imgs%2FtoString%28%29%20%EC%9E%AC%EC%A0%95%EC%9D%98.png)

### 객체의 참조값 직접 출력
`toString()`은 기본적으로 객체의 참조값을 출력한다. 그런데 `toString()`이나 `hashCode()`를 재정의하면 객체의 참조값을 출력할 수 없다.
이때는 다음 코드를 사용하면 객체의 참조값을 출력할 수 있다.
```java
String refValue = Integer.toHexString(System.identityHashCode(data));
System.out.println("refValue = refValue");
```

## Object와 OCP
만약 `Object`가 없고, 또 `Object`가 제공하는 `toString()`이 없다면 서로 아무 관계가 없는 객체의 정보를 출력하기 어려울 것이다.
여기서 아무 관계가 없다는 것은 부모가 없다는 뜻이다. 아마도 다음의 `BadObjectPrinter`클래스와 같이 각각의 클래스마다 별도의 메서드를 작성해야 할 것이다.

### BadObjectPrinter.java
```java
public class BadObjectPrinter {
    public static void print(Car car) {
        String string = "객체 정보 출력: " + car.carInfo();
        System.out.println(string);
    }
    
    public static void print(Dog dog) {
        String string = "객체 정보 출력: " + dog.dogInfo();
        System.out.println(string);
    }
}
```

### 구체적인 것에 의존
`BadObjectPrinter`는 구체적인 타입인 `Car`, `Dog`를 사용한다.
따라서 이후에 출력해야할 구체적인 클래스가 10개로 늘어나면 구체적인 클래스에 맞추어 메서드도 10개로 늘어날 것이다.
이렇게 `BadObjectPrinter` 클래스가 구체적인 특정 클래스인 `Car`, `Dog`를 사용하는 것을 `BadObjectPrinter`는 `Car`, `Dog`에 의존한다고 표현한다.


다행히도 자바에는 **객체의 정보를 사용할 때**, 다형적 참조 문제를 해결해줄 `Object`클래스와 메서드 오버라이딩 문제를 해결해줄
`Object.toString()`메서드가 있다.(물론 `Object`와 비슷한 공통의 부모 클래스를 만들어서 해결할 수도 있다.)

### 추상적인 것에 의존
우리가 앞서 만든 `ObjectPrinter`클래스는 `Car`, `Dog` 같은 구체적인 클래스를 사용하는 것이 아니라, 
추상적인 `Object` 클래스를 사용한다. 이렇게 `ObjectPrinter`클래스가 `Object`클래스를 사용하는 것을
`ObjectPrinter`클래스가 `Object`클래스에 의존한다고 표현한다.

```java
public class ObjectPrinter {
    public static void print(Object obj) {
        String string = "객체 정보 출력: " + obj.toString();
        System.out.println(string);
    }
}
```
`ObjectPrinter`는 구체적인 것에 의존하는 것이 아니라 추상적인 것에 의존한다.

> 🍀 추상적  
> 여기서 말하는 추상적이라는 뜻은 단순히 추상 클래스나 인터페이스만 뜻하는 것은 아니다.  
> `Animal`과 `Dog`, `Cat`의 관계를 떠올려보자. `Animal`같은 부모 타입으로 올라갈 수록 개념은 더 추상적이게 되고,
> `Dog`, `Cat`과 같이 하위 타입으로 내려갈 수록 더 구체적이게 된다.

![의존 관계.png](imgs%2F%EC%9D%98%EC%A1%B4%20%EA%B4%80%EA%B3%84.png)

`ObjectPrinter`의 `Object`를 사용하는 구조는 다형성을 매우 잘 활용하고 있다.
다형성을 잘 활용한다는 것은 다형적 참조와 메서드 오버라이딩을 적절하게 사용한다는 뜻이다.

`ObjectPrinter`의 `print()`메서드와 전체 구조를 분석해보자.
- 다형적 참조: `print(Object obj)`, `Object` 타입을 매개변수로 사용해서 다형적 참조를 사용한다.
`Car`, `Dog` 인스턴스를 포함한 세상의 모든 객체 인스턴스를 인수로 받을 수 잇다.
- 메서드 오버라이딩: `Object`는 모든 클래스의 부모이다. 따라서 `Dog`, `Car`와 같은 구체적인 클래스는 `Object`가 가지고 있는
`toString()`메서드를 오버라이딩 할 수 있다. 따라서 `print(Object obj)`메서드는 `Dog`, `Car`와 같은 구체적인 타입에 의존(사용)하지 않고,
추상적인 `Object` 타입에 의존하면서 런타임에 각 인스턴스의 `toString()`을 호출할 수 있다.

### OCP 원칙
- Open: 새로운 클래스를 추가하고, `toString()`을 오버라이딩해서 기능을 확장할 수 있다.
- Closed: 새로운 클래스를 추가해도 `Object`와 `toString()`을 사용하는 클라이언트 코드인 `ObjectPrinter`는 변경하지 않아도 된다.

다형적 참조, 메서드 오버라이딩, 클라이언트 코드가 구체적인 `Car`, `Dog`,에 의존하는 것이 아니라
추상적인 `Objecg`에 의존하면서 OCP 원칙을 지킬 수 있었다.
덕분에 새로운 클래스를 추가하고 `toString()`메서드를 새롭게 오버라이딩해서 기능을 확장할 수 있다.
이러한 변화에도 불구하고 클라이언트 코드인 `ObjectPrinter`는 변경할 필요가 없다.

`ObjectPrinter`는 모든 타입의 부모인 `Object`를 사용하고, `Object`가 제공하는 `toString()`메서드만 사용한다.
따라서 `ObjectPrinter`를 사용하면 세상의 모든 객체 정보(`toString()`)를 편리하게 출력할 수 있다.

## System.out.println()
`System.out.println()`메서드도 `Object` 매개변수를 사용하고 내부에서 `toString()`을 호출한다.
따라서 `System.out.println()`을 사용하면 세상의 모든 객체 정보(`toString()`)을 편리하게 출력할 수 있다.

자바 언어는 객체지향 언어 답게 언어 스스로도 객체지향의 특징을 매우 잘 활용한다.  
자바 언어가 기본적으로 제공하는 다양한 메서드들은 개발자가 필요에 따라 오버라이딩 할 수 있도록 설계되어있다.

> 🍀 정적 의존관계 vs 동적 의존관계  
> - 정적 의존관계는 컴파일 시간에 결정되며, 주로 클래스 간의 관계를 의미한다. 앞서 보여준 클래스 의존 관계 그림이 바로정적 의존관계이다.
> 쉽게 이야기해서 프로그램을 실행하지 않고, 클래스 내에서 사용하는 타입들만 보면 쉽게 의존관계를 파악할 수 있다.  
> - 동적 의존관계는 프로그램을 실행하는 런타임에 확인할 수 있는 의존관계이다. 앞서 
> `ObjectPrinter.print(Object obj)`에 인자로 어떤 객체가 전달 될 지는 프로그램을 실행해봐야 알 수 있다.
> 이렇게 런타임에 어떤 인스턴스를 사용하지를 나타내는 것이 동적 의존관계이다.
> 
> 참고로 단순히 의존관계 또는 어디에 의존한다. 라고하면 정적 의존관계를 뜻한다.  
> 예) `ObjectPrinter`는 `Object`에 의존한다.